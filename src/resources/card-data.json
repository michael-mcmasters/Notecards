{
  "cards": [
    {
      "backgroundColor": "#",
      "frontText": " ",
      "backText": "",
      "timesAccepted": "0"
    },
    {
      "backgroundColor": "#31587A",
      "frontText": "What are the 4 principles of Object Oriented Programming?",
      "backText": "A PIE. Abstraction, Polymorphism, Inheritance, Encapsulation",
      "timesAccepted": "0"
    },
    {
      "backgroundColor": "#E8525B",
      "frontText": "Explain abstraction",
      "backText": "Abstraction means using simple things to represent complexity. In Java, abstraction means simple things like objects, classes, and variables represent more complex underlying code and data. This is important because it lets us avoid repeating the same work multiple times. It handles complexity by hiding unnecessary details from the user",
      "timesAccepted": "0"
    },
    {
      "backgroundColor": "#E8525B",
      "frontText": "Explain polymorphism",
      "backText": "SAME NAME, MANY FORMS. This Java OOP concept lets programmers use the same word to mean different things in different contexts. One form of polymorphism in Java is method overloading. That’s when different meanings are implied by the code itself. The other form is method overriding. That’s when the different meanings are implied by the values of the supplied variables. TWO TYPES: Runtime , Polymorphism handled during runtime: example (Overriding) Static , Polymorphism handled in the compiler: example (Overloading)",
      "timesAccepted": "0"
    },
    {
      "backgroundColor": "#31587A",
      "frontText": "Explain inheritance",
      "backText": "This is a special feature of Object Oriented Programming in Java. It lets programmers create new classes that share some of the attributes of existing classes. This lets us build on previous work without reinventing the wheel. * The ability for a sub class to access the super class's members implicitly through the keyword 'extends'; Members include methods as well as variables.",
      "timesAccepted": "0"
    },
    {
      "backgroundColor": "#31587A",
      "frontText": "Explain encapsulation",
      "backText": "This is the practice of keeping fields within a class private, then providing access to them via public methods. It’s a protective barrier that keeps the data and code safe within the class itself. This way, we can re-use objects like code components or variables without allowing open access to the data system-wide.",
      "timesAccepted": "0"
    },
    {
      "backgroundColor": "#31587A",
      "frontText": "What are the 4 access modifiers and their access specifiers",
      "backText": "Public: Class, Package, Subclass, Global, Variable Protected: Class, Package, Subclass Default: Class, Package Private: Class, Variable",
      "timesAccepted": "0"
    },
    {
      "backgroundColor": "#31587A",
      "frontText": "What are the 5 SOLID principles?",
      "backText": "Single Responsibility, Open/Close Principle, Liskov's Substitution Principle, Interface Segregation Principle, Dependency Inversion",
      "timesAccepted": "0"
    },
    {
      "backgroundColor": "#31587A",
      "frontText": "Explain 'Single Responsibility'",
      "backText": "a class should have only a single responsibility (i.e. changes to only one part of the software's specification should be able to affect the specification of the class).",
      "timesAccepted": "0"
    },
    {
      "backgroundColor": "yellow",
      "frontText": "Explain 'Open/Close Principle'",
      "backText": "'open for extension, but closed for modification.' classes' properties can be inherited and used by subclasses etc, but not altered directly",
      "timesAccepted": "0"
    },
    {
      "backgroundColor": "#31587A",
      "frontText": "Explain 'Liskov's Substitution Principle",
      "backText": "'objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program.'",
      "timesAccepted": "0"
    },
    {
      "backgroundColor": "#31587A",
      "frontText": "Explain 'Interface Segregation Principle'",
      "backText": "'many client-specific interfaces are better than one general-purpose interface.' in other words, when you implement an interface, do you want your class flooded with empty methods you'll never use, or just the few that offer the functionality you are looking for?",
      "timesAccepted": "0"
    },
    {
      "backgroundColor": "#31587A",
      "frontText": "Explain 'Dependency Inversion'",
      "backText": "one should 'depend upon abstractions, [not] concretions.' In other words--don't extend ArrayList class to get those functions; implement List interface instead.",
      "timesAccepted": "0"
    },
    {
      "backgroundColor": "#31587A",
      "frontText": "What is the difference between overloading and overriding?",
      "backText": "Overloading occurs when two or more methods in one class have the same method name but different parameters. Overriding means having two methods with the same method name and parameters (i.e., method signature). One of the methods is in the parent class and the other is in the child class. Overriding changes the BEHAVIOR of the method.",
      "timesAccepted": "0"
    }
  ]
}
